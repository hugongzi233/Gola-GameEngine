<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Engine/gola_app.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Engine/gola_app.cpp" />
              <option name="originalContent" value="#include &quot;gola_app.hpp&quot;&#10;&#10;#define GLM_FORCE_RADIANS&#10;#define GLM_FORCE_DEPTH_ZERO_TO_ONE&#10;#include &lt;glm.hpp&gt;&#10;#include &lt;gtc/constants.hpp&gt;&#10;&#10;#include &lt;chrono&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;thread&gt;&#10;&#10;namespace gola {&#10;    struct SimplePushConstantData {&#10;        glm::mat2 transform{1.0f};&#10;&#10;        glm::vec2 offset;&#10;        alignas(16) glm::vec4 color;&#10;    };&#10;&#10;    GolaApp::GolaApp() {&#10;        loadGameObjects();&#10;        createPipelineLayout();&#10;&#10;        auto extent = window.getExtent();&#10;        std::cout &lt;&lt; extent.width &lt;&lt; &quot; &quot; &lt;&lt; extent.height &lt;&lt; std::endl;&#10;        swapChain = std::make_unique&lt;GolaSwapChain&gt;(device, extent);&#10;&#10;        createPipeline();&#10;        // Initialize ImGui after swapchain and pipeline/renderpass are available&#10;        imgui = std::make_unique&lt;GolaImgui&gt;();&#10;        imgui-&gt;init(device, *swapChain, window.getGLFWwindow());&#10;&#10;        // recreateSwapChain();&#10;        createCommandBuffers();&#10;    }&#10;&#10;    GolaApp::~GolaApp() {&#10;        if (pipeline) {&#10;            vkDestroyPipelineLayout(device.device(), pipelineLayout, nullptr);&#10;        }&#10;        if (imgui) {&#10;            imgui-&gt;cleanup();&#10;            imgui.reset();&#10;        }&#10;    }&#10;&#10;    void GolaApp::run() {&#10;        // 主循环逻辑&#10;        while (!window.shouldClose()) {&#10;            glfwPollEvents();&#10;            drawFrame();&#10;            // Render and update logic would go here&#10;            int renderedFrames = 60;&#10;            std::this_thread::sleep_for(std::chrono::milliseconds(1000 / renderedFrames));&#10;        }&#10;&#10;        vkDeviceWaitIdle(device.device());&#10;    }&#10;&#10;    void GolaApp::loadGameObjects() {&#10;        std::vector&lt;GolaModel::Vertex&gt; vertices = {&#10;            {{0.0f, -0.5f}, {1.0f, 0.0f, 0.0f}}, // v0&#10;            {{0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}}, // v1&#10;            {{-0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}}, // v2&#10;        };&#10;        auto model = std::make_shared&lt;GolaModel&gt;(device, vertices);&#10;&#10;        auto triangle = GolaGameObject::createGameObject();&#10;        triangle.model = model;&#10;        triangle.color = {0.1f, 1.0f, 0.1f,1.f};&#10;        triangle.transform2d.translation.x = 0.f;&#10;        triangle.transform2d.scale = {2.0f, 0.5f};&#10;        triangle.transform2d.rotation = 0.25f * glm::two_pi&lt;float&gt;();&#10;&#10;        gameobjects.push_back(std::move(triangle));&#10;    }&#10;&#10;    void GolaApp::createPipelineLayout() {&#10;        VkPushConstantRange pushConstantRange{};&#10;        pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;&#10;        pushConstantRange.offset = 0;&#10;        pushConstantRange.size = sizeof(SimplePushConstantData);&#10;&#10;        VkPipelineLayoutCreateInfo pipelineLayoutInfo{};&#10;        pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;&#10;        pipelineLayoutInfo.setLayoutCount = 0;&#10;        pipelineLayoutInfo.pSetLayouts = nullptr; // No descriptor sets for now&#10;        pipelineLayoutInfo.pushConstantRangeCount = 1; // No push constants for now&#10;        pipelineLayoutInfo.pPushConstantRanges = &amp;pushConstantRange; // No push constants for now&#10;        if (vkCreatePipelineLayout(device.device(), &amp;pipelineLayoutInfo, nullptr, &amp;pipelineLayout) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to create pipeline layout&quot;);&#10;        }&#10;    }&#10;&#10;    void GolaApp::createPipeline() {&#10;        assert(swapChain!=nullptr&amp;&amp; &quot;Cannot create pipeline before swap chain&quot;);&#10;        assert(pipelineLayout!=nullptr&amp;&amp; &quot;Cannot create pipeline before pipeline layout&quot;);&#10;&#10;        PipelineConfigInfo pipelineConfig{};&#10;        GolaPipeline::defaultPipelineConfigInfo(pipelineConfig);&#10;        //PipelineConfigInfo configInfo = GolaPipeline::defaultPipelineConfigInfo(WIDTH, HEIGHT);&#10;        pipelineConfig.renderPass = swapChain-&gt;getRenderPass();&#10;        pipelineConfig.pipelineLayout = pipelineLayout;&#10;        pipeline = std::make_unique&lt;GolaPipeline&gt;(&#10;            device,&#10;            &quot;Engine/shaders/simple_shader.vert.spv&quot;,&#10;            &quot;Engine/shaders/simple_shader.frag.spv&quot;,&#10;            pipelineConfig);&#10;    }&#10;&#10;    void GolaApp::createCommandBuffers() {&#10;        commandBuffers.resize(swapChain-&gt;imageCount());&#10;&#10;        VkCommandBufferAllocateInfo allocInfo{};&#10;        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;&#10;        allocInfo.commandPool = device.getCommandPool();&#10;        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;&#10;        allocInfo.commandBufferCount = static_cast&lt;uint32_t&gt;(commandBuffers.size());&#10;&#10;        if (vkAllocateCommandBuffers(device.device(), &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to allocate command buffers&quot;);&#10;        }&#10;&#10;        for (int i = 0; i &lt; commandBuffers.size(); i++) {&#10;            recordCommandBuffers(i);&#10;        }&#10;    }&#10;&#10;    void GolaApp::freeCommandBuffers() {&#10;        vkFreeCommandBuffers(&#10;            device.device(),&#10;            device.getCommandPool(),&#10;            static_cast&lt;uint32_t&gt;(commandBuffers.size()),&#10;            commandBuffers.data());&#10;        commandBuffers.clear();&#10;    }&#10;&#10;    void GolaApp::recordCommandBuffers(int imageIndex) {&#10;        // Start ImGui frame and build UI for this frame&#10;        if (imgui) {&#10;            imgui-&gt;newFrame();&#10;            imgui-&gt;buildUI();&#10;        }&#10;&#10;        // 重置命令缓冲区&#10;        vkResetCommandBuffer(commandBuffers[imageIndex], 0);&#10;&#10;        // anim test&#10;        static int frame = 0;&#10;        frame = (frame + 1) % 500;&#10;&#10;        VkCommandBufferBeginInfo beginInfo{};&#10;        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;&#10;&#10;        if (vkBeginCommandBuffer(commandBuffers[imageIndex], &amp;beginInfo) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to begin recording command buffer&quot;);&#10;        }&#10;&#10;        VkRenderPassBeginInfo renderPassInfo{};&#10;        renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;&#10;        renderPassInfo.renderPass = swapChain-&gt;getRenderPass();&#10;        renderPassInfo.framebuffer = swapChain-&gt;getFrameBuffer(imageIndex);&#10;        renderPassInfo.renderArea.offset = {0, 0};&#10;        renderPassInfo.renderArea.extent = swapChain-&gt;getSwapChainExtent();&#10;        std::array&lt;VkClearValue, 2&gt; clearValues{};&#10;        clearValues[0].color = {0.01f, 0.01f, 0.01f, 1.0f};&#10;        clearValues[1].depthStencil = {1.0f, 0};&#10;        renderPassInfo.clearValueCount = static_cast&lt;uint32_t&gt;(clearValues.size());&#10;        renderPassInfo.pClearValues = clearValues.data();&#10;        vkCmdBeginRenderPass(commandBuffers[imageIndex], &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);&#10;&#10;        VkViewport viewport{};&#10;        viewport.x = 0.0f;&#10;        viewport.y = 0.0f;&#10;        viewport.width = static_cast&lt;float&gt;(swapChain-&gt;getSwapChainExtent().width);&#10;        viewport.height = static_cast&lt;float&gt;(swapChain-&gt;getSwapChainExtent().height);&#10;        viewport.minDepth = 0.0f;&#10;        viewport.maxDepth = 1.0f;&#10;        VkRect2D scissor{{0, 0}, swapChain-&gt;getSwapChainExtent()};&#10;        vkCmdSetViewport(commandBuffers[imageIndex], 0, 1, &amp;viewport);&#10;        vkCmdSetScissor(commandBuffers[imageIndex], 0, 1, &amp;scissor);&#10;&#10;        renderGameObjects(commandBuffers[imageIndex]);&#10;&#10;        // Render ImGui on top&#10;        if (imgui) {&#10;            imgui-&gt;render(commandBuffers[imageIndex]);&#10;        }&#10;&#10;        vkCmdEndRenderPass(commandBuffers[imageIndex]);&#10;&#10;        if (vkEndCommandBuffer(commandBuffers[imageIndex]) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to record command buffer&quot;);&#10;        }&#10;    }&#10;&#10;    void GolaApp::recreateSwapChain() {&#10;        auto extent = window.getExtent();&#10;&#10;        // 等待窗口有效大小&#10;        while (extent.width == 0 || extent.height == 0) {&#10;            extent = window.getExtent();&#10;            glfwWaitEvents();&#10;        }&#10;&#10;        vkDeviceWaitIdle(device.device());&#10;&#10;        // 先清理pipeline和command buffer，再清理swapchain&#10;        commandBuffers.clear();&#10;        if (pipeline) {&#10;            pipeline.reset();&#10;        }&#10;        if (swapChain) {&#10;            swapChain.reset();&#10;        }&#10;&#10;        if (swapChain == nullptr) {&#10;            swapChain = std::make_unique&lt;GolaSwapChain&gt;(device, extent);&#10;        } else {&#10;            swapChain = std::make_unique&lt;GolaSwapChain&gt;(device, extent, std::move(swapChain));&#10;            if (swapChain-&gt;imageCount() != commandBuffers.size()) {&#10;                freeCommandBuffers();&#10;                createCommandBuffers();&#10;            }&#10;        }&#10;&#10;        createPipeline();&#10;        if (imgui) {&#10;            imgui-&gt;cleanup();&#10;            imgui-&gt;init(device, *swapChain, window.getGLFWwindow());&#10;        }&#10;&#10;        createCommandBuffers();&#10;    }&#10;&#10;    void GolaApp::renderGameObjects(VkCommandBuffer commandBuffer) {&#10;        pipeline-&gt;bind(commandBuffer);&#10;&#10;        for (auto &amp;obj: gameobjects) {&#10;            obj.transform2d.rotation = glm::mod(obj.transform2d.rotation + 0.01f, glm::two_pi&lt;float&gt;());&#10;&#10;            SimplePushConstantData push{};&#10;            push.offset = obj.transform2d.translation;&#10;            push.color = obj.color;&#10;            push.transform = obj.transform2d.mat2();&#10;&#10;            vkCmdPushConstants(&#10;                commandBuffer,&#10;                pipelineLayout,&#10;                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,&#10;                0,&#10;                sizeof(SimplePushConstantData),&#10;                &amp;push);&#10;&#10;            obj.model-&gt;bind(commandBuffer);&#10;            obj.model-&gt;draw(commandBuffer);&#10;        }&#10;    }&#10;&#10;&#10;    void GolaApp::drawFrame() {&#10;        // static int frameCount = 0;&#10;        // frameCount++;&#10;        // std::cout &lt;&lt; &quot;=== Frame &quot; &lt;&lt; frameCount &lt;&lt; &quot; ===&quot; &lt;&lt; std::endl;&#10;&#10;        if (window.shouldClose()) {&#10;            std::cout &lt;&lt; &quot;Window should close!&quot; &lt;&lt; std::endl;&#10;            return;&#10;        }&#10;&#10;        uint32_t imageIndex;&#10;        VkResult result = swapChain-&gt;acquireNextImage(&amp;imageIndex);&#10;&#10;        if (result == VK_ERROR_OUT_OF_DATE_KHR) {&#10;            recreateSwapChain();&#10;            return;&#10;        }&#10;        if (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) {&#10;            throw std::runtime_error(&quot;Failed to acquire swap chain image&quot;);&#10;        }&#10;&#10;        // 等待上一帧的 fence，确保命令缓冲区不在 pending 状态&#10;        // VkFence fence = swapChain-&gt;getInFlightFence(imageIndex);&#10;        // vkWaitForFences(device.device(), 1, &amp;fence, VK_TRUE, UINT64_MAX);&#10;        // vkResetFences(device.device(), 1, &amp;fence);&#10;&#10;        // Re-record the command buffer for the acquired image so UI and dynamic content are up-to-date&#10;        recordCommandBuffers(imageIndex);&#10;&#10;        result = swapChain-&gt;submitCommandBuffers(&amp;commandBuffers[imageIndex], &amp;imageIndex);&#10;&#10;        if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || window.wasFramebufferResized()) {&#10;            window.resetFramebufferResizedFlag();&#10;            recreateSwapChain();&#10;        } else if (result != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to submit command buffer&quot;);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="#include &quot;gola_app.hpp&quot;&#10;&#10;#define GLM_FORCE_RADIANS&#10;#define GLM_FORCE_DEPTH_ZERO_TO_ONE&#10;#include &lt;glm.hpp&gt;&#10;#include &lt;gtc/constants.hpp&gt;&#10;&#10;#include &lt;chrono&gt;&#10;#include &lt;iostream&gt;&#10;#include &lt;thread&gt;&#10;&#10;namespace gola {&#10;    struct SimplePushConstantData {&#10;        glm::mat2 transform{1.0f};&#10;&#10;        glm::vec2 offset;&#10;        alignas(16) glm::vec4 color;&#10;    };&#10;&#10;    GolaApp::GolaApp() {&#10;        loadGameObjects();&#10;        createPipelineLayout();&#10;&#10;        auto extent = window.getExtent();&#10;        std::cout &lt;&lt; extent.width &lt;&lt; &quot; &quot; &lt;&lt; extent.height &lt;&lt; std::endl;&#10;        swapChain = std::make_unique&lt;GolaSwapChain&gt;(device, extent);&#10;&#10;        createPipeline();&#10;        // Initialize ImGui after swapchain and pipeline/renderpass are available&#10;        imgui = std::make_unique&lt;GolaImgui&gt;();&#10;        imgui-&gt;init(device, *swapChain, window.getGLFWwindow());&#10;&#10;        // recreateSwapChain();&#10;        createCommandBuffers();&#10;    }&#10;&#10;    GolaApp::~GolaApp() {&#10;        if (pipeline) {&#10;            vkDestroyPipelineLayout(device.device(), pipelineLayout, nullptr);&#10;        }&#10;        if (imgui) {&#10;            imgui-&gt;cleanup();&#10;            imgui.reset();&#10;        }&#10;    }&#10;&#10;    void GolaApp::run() {&#10;        // 主循环逻辑&#10;        while (!window.shouldClose()) {&#10;            glfwPollEvents();&#10;            drawFrame();&#10;            // Render and update logic would go here&#10;            int renderedFrames = 60;&#10;            std::this_thread::sleep_for(std::chrono::milliseconds(1000 / renderedFrames));&#10;        }&#10;&#10;        vkDeviceWaitIdle(device.device());&#10;    }&#10;&#10;    void GolaApp::loadGameObjects() {&#10;        std::vector&lt;GolaModel::Vertex&gt; vertices = {&#10;            {{0.0f, -0.5f}, {1.0f, 0.0f, 0.0f}}, // v0&#10;            {{0.5f, 0.5f}, {0.0f, 1.0f, 0.0f}}, // v1&#10;            {{-0.5f, 0.5f}, {0.0f, 0.0f, 1.0f}}, // v2&#10;        };&#10;        auto model = std::make_shared&lt;GolaModel&gt;(device, vertices);&#10;&#10;        auto triangle = GolaGameObject::createGameObject();&#10;        triangle.model = model;&#10;        triangle.color = {0.1f, 1.0f, 0.1f,1.f};&#10;        triangle.transform2d.translation.x = 0.f;&#10;        triangle.transform2d.scale = {2.0f, 0.5f};&#10;        triangle.transform2d.rotation = 0.25f * glm::two_pi&lt;float&gt;();&#10;&#10;        gameobjects.push_back(std::move(triangle));&#10;    }&#10;&#10;    void GolaApp::createPipelineLayout() {&#10;        VkPushConstantRange pushConstantRange{};&#10;        pushConstantRange.stageFlags = VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT;&#10;        pushConstantRange.offset = 0;&#10;        pushConstantRange.size = sizeof(SimplePushConstantData);&#10;&#10;        VkPipelineLayoutCreateInfo pipelineLayoutInfo{};&#10;        pipelineLayoutInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO;&#10;        pipelineLayoutInfo.setLayoutCount = 0;&#10;        pipelineLayoutInfo.pSetLayouts = nullptr; // No descriptor sets for now&#10;        pipelineLayoutInfo.pushConstantRangeCount = 1; // No push constants for now&#10;        pipelineLayoutInfo.pPushConstantRanges = &amp;pushConstantRange; // No push constants for now&#10;        if (vkCreatePipelineLayout(device.device(), &amp;pipelineLayoutInfo, nullptr, &amp;pipelineLayout) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to create pipeline layout&quot;);&#10;        }&#10;    }&#10;&#10;    void GolaApp::createPipeline() {&#10;        assert(swapChain!=nullptr&amp;&amp; &quot;Cannot create pipeline before swap chain&quot;);&#10;        assert(pipelineLayout!=nullptr&amp;&amp; &quot;Cannot create pipeline before pipeline layout&quot;);&#10;&#10;        PipelineConfigInfo pipelineConfig{};&#10;        GolaPipeline::defaultPipelineConfigInfo(pipelineConfig);&#10;        //PipelineConfigInfo configInfo = GolaPipeline::defaultPipelineConfigInfo(WIDTH, HEIGHT);&#10;        pipelineConfig.renderPass = swapChain-&gt;getRenderPass();&#10;        pipelineConfig.pipelineLayout = pipelineLayout;&#10;        pipeline = std::make_unique&lt;GolaPipeline&gt;(&#10;            device,&#10;            &quot;Engine/shaders/simple_shader.vert.spv&quot;,&#10;            &quot;Engine/shaders/simple_shader.frag.spv&quot;,&#10;            pipelineConfig);&#10;    }&#10;&#10;    void GolaApp::createCommandBuffers() {&#10;        commandBuffers.resize(swapChain-&gt;imageCount());&#10;&#10;        VkCommandBufferAllocateInfo allocInfo{};&#10;        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;&#10;        allocInfo.commandPool = device.getCommandPool();&#10;        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;&#10;        allocInfo.commandBufferCount = static_cast&lt;uint32_t&gt;(commandBuffers.size());&#10;&#10;        if (vkAllocateCommandBuffers(device.device(), &amp;allocInfo, commandBuffers.data()) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to allocate command buffers&quot;);&#10;        }&#10;&#10;        for (int i = 0; i &lt; commandBuffers.size(); i++) {&#10;            recordCommandBuffers(i);&#10;        }&#10;    }&#10;&#10;    void GolaApp::freeCommandBuffers() {&#10;        vkFreeCommandBuffers(&#10;            device.device(),&#10;            device.getCommandPool(),&#10;            static_cast&lt;uint32_t&gt;(commandBuffers.size()),&#10;            commandBuffers.data());&#10;        commandBuffers.clear();&#10;    }&#10;&#10;    void GolaApp::recordCommandBuffers(int imageIndex) {&#10;        // Start ImGui frame and build UI for this frame&#10;        if (imgui) {&#10;            imgui-&gt;newFrame();&#10;            imgui-&gt;buildUI();&#10;        }&#10;&#10;        // 重置命令缓冲区&#10;        vkResetCommandBuffer(commandBuffers[imageIndex], 0);&#10;&#10;        // anim test&#10;        static int frame = 0;&#10;        frame = (frame + 1) % 500;&#10;&#10;        VkCommandBufferBeginInfo beginInfo{};&#10;        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;&#10;&#10;        if (vkBeginCommandBuffer(commandBuffers[imageIndex], &amp;beginInfo) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to begin recording command buffer&quot;);&#10;        }&#10;&#10;        VkRenderPassBeginInfo renderPassInfo{};&#10;        renderPassInfo.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;&#10;        renderPassInfo.renderPass = swapChain-&gt;getRenderPass();&#10;        renderPassInfo.framebuffer = swapChain-&gt;getFrameBuffer(imageIndex);&#10;        renderPassInfo.renderArea.offset = {0, 0};&#10;        renderPassInfo.renderArea.extent = swapChain-&gt;getSwapChainExtent();&#10;        std::array&lt;VkClearValue, 2&gt; clearValues{};&#10;        clearValues[0].color = {0.01f, 0.01f, 0.01f, 1.0f};&#10;        clearValues[1].depthStencil = {1.0f, 0};&#10;        renderPassInfo.clearValueCount = static_cast&lt;uint32_t&gt;(clearValues.size());&#10;        renderPassInfo.pClearValues = clearValues.data();&#10;        vkCmdBeginRenderPass(commandBuffers[imageIndex], &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);&#10;&#10;        VkViewport viewport{};&#10;        viewport.x = 0.0f;&#10;        viewport.y = 0.0f;&#10;        viewport.width = static_cast&lt;float&gt;(swapChain-&gt;getSwapChainExtent().width);&#10;        viewport.height = static_cast&lt;float&gt;(swapChain-&gt;getSwapChainExtent().height);&#10;        viewport.minDepth = 0.0f;&#10;        viewport.maxDepth = 1.0f;&#10;        VkRect2D scissor{{0, 0}, swapChain-&gt;getSwapChainExtent()};&#10;        vkCmdSetViewport(commandBuffers[imageIndex], 0, 1, &amp;viewport);&#10;        vkCmdSetScissor(commandBuffers[imageIndex], 0, 1, &amp;scissor);&#10;&#10;        renderGameObjects(commandBuffers[imageIndex]);&#10;&#10;        // Render ImGui on top&#10;        if (imgui) {&#10;            imgui-&gt;render(commandBuffers[imageIndex]);&#10;        }&#10;&#10;        vkCmdEndRenderPass(commandBuffers[imageIndex]);&#10;&#10;        if (vkEndCommandBuffer(commandBuffers[imageIndex]) != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to record command buffer&quot;);&#10;        }&#10;    }&#10;&#10;    void GolaApp::recreateSwapChain() {&#10;        auto extent = window.getExtent();&#10;&#10;        // 等待窗口有效大小&#10;        while (extent.width == 0 || extent.height == 0) {&#10;            extent = window.getExtent();&#10;            glfwWaitEvents();&#10;        }&#10;&#10;        vkDeviceWaitIdle(device.device());&#10;&#10;        // 先清理pipeline和command buffer，再清理swapchain&#10;        commandBuffers.clear();&#10;        if (pipeline) {&#10;            pipeline.reset();&#10;        }&#10;        if (swapChain) {&#10;            swapChain.reset();&#10;        }&#10;&#10;        if (swapChain == nullptr) {&#10;            swapChain = std::make_unique&lt;GolaSwapChain&gt;(device, extent);&#10;        } else {&#10;            swapChain = std::make_unique&lt;GolaSwapChain&gt;(device, extent, std::move(swapChain));&#10;            if (swapChain-&gt;imageCount() != commandBuffers.size()) {&#10;                freeCommandBuffers();&#10;                createCommandBuffers();&#10;            }&#10;        }&#10;&#10;        createPipeline();&#10;        if (imgui) {&#10;            imgui-&gt;cleanup();&#10;            imgui-&gt;init(device, *swapChain, window.getGLFWwindow());&#10;        }&#10;&#10;        createCommandBuffers();&#10;    }&#10;&#10;    void GolaApp::renderGameObjects(VkCommandBuffer commandBuffer) {&#10;        pipeline-&gt;bind(commandBuffer);&#10;&#10;        for (auto &amp;obj: gameobjects) {&#10;            obj.transform2d.rotation = glm::mod(obj.transform2d.rotation + 0.01f, glm::two_pi&lt;float&gt;());&#10;&#10;            SimplePushConstantData push{};&#10;            push.offset = obj.transform2d.translation;&#10;            push.color = obj.color;&#10;            push.transform = obj.transform2d.mat2();&#10;&#10;            vkCmdPushConstants(&#10;                commandBuffer,&#10;                pipelineLayout,&#10;                VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_FRAGMENT_BIT,&#10;                0,&#10;                sizeof(SimplePushConstantData),&#10;                &amp;push);&#10;&#10;            obj.model-&gt;bind(commandBuffer);&#10;            obj.model-&gt;draw(commandBuffer);&#10;        }&#10;    }&#10;&#10;&#10;    void GolaApp::drawFrame() {&#10;        // static int frameCount = 0;&#10;        // frameCount++;&#10;        // std::cout &lt;&lt; &quot;=== Frame &quot; &lt;&lt; frameCount &lt;&lt; &quot; ===&quot; &lt;&lt; std::endl;&#10;&#10;        if (window.shouldClose()) {&#10;            std::cout &lt;&lt; &quot;Window should close!&quot; &lt;&lt; std::endl;&#10;            return;&#10;        }&#10;&#10;        uint32_t imageIndex;&#10;        VkResult result = swapChain-&gt;acquireNextImage(&amp;imageIndex);&#10;&#10;        if (result == VK_ERROR_OUT_OF_DATE_KHR) {&#10;            recreateSwapChain();&#10;            return;&#10;        }&#10;        if (result != VK_SUCCESS &amp;&amp; result != VK_SUBOPTIMAL_KHR) {&#10;            throw std::runtime_error(&quot;Failed to acquire swap chain image&quot;);&#10;        }&#10;&#10;        // 等待上一帧的 fence，确保命令缓冲区不在 pending 状态&#10;        // VkFence fence = swapChain-&gt;getInFlightFence(imageIndex);&#10;        // vkWaitForFences(device.device(), 1, &amp;fence, VK_TRUE, UINT64_MAX);&#10;        // vkResetFences(device.device(), 1, &amp;fence);&#10;&#10;        // Re-record the command buffer for the acquired image so UI and dynamic content are up-to-date&#10;        recordCommandBuffers(imageIndex);&#10;&#10;        result = swapChain-&gt;submitCommandBuffers(&amp;commandBuffers[imageIndex], &amp;imageIndex);&#10;&#10;        if (result == VK_ERROR_OUT_OF_DATE_KHR || result == VK_SUBOPTIMAL_KHR || window.wasFramebufferResized()) {&#10;            window.resetFramebufferResizedFlag();&#10;            recreateSwapChain();&#10;        } else if (result != VK_SUCCESS) {&#10;            throw std::runtime_error(&quot;Failed to submit command buffer&quot;);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>